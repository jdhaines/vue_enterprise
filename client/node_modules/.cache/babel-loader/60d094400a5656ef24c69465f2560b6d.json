{"remainingRequest":"/var/www/vue_enterprise/client/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js!/var/www/vue_enterprise/client/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/var/www/vue_enterprise/client/src/router/index.js","dependencies":[{"path":"/var/www/vue_enterprise/client/src/router/index.js","mtime":1565713332546},{"path":"/var/www/vue_enterprise/client/.babelrc.js","mtime":1565713332537},{"path":"/var/www/vue_enterprise/client/node_modules/cache-loader/dist/cjs.js","mtime":1565713649664},{"path":"/var/www/vue_enterprise/client/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js","mtime":1565713477729},{"path":"/var/www/vue_enterprise/client/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1565713590178}],"contextDependencies":[],"result":["import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/var/www/vue_enterprise/client/node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/builtin/es6/asyncToGenerator\";\nimport \"core-js/modules/es6.function.name\";\nimport Vue from 'vue';\nimport VueRouter from 'vue-router'; // https://github.com/declandewet/vue-meta\n\nimport VueMeta from 'vue-meta'; // Adds a loading bar at the top during page loads.\n\nimport NProgress from 'nprogress/nprogress';\nimport store from '@state/store';\nimport routes from './routes';\nVue.use(VueRouter);\nVue.use(VueMeta, {\n  // The component option name that vue-meta looks for meta info on.\n  keyName: 'page'\n});\nvar router = new VueRouter({\n  routes: routes,\n  // Use the HTML5 history API (i.e. normal-looking routes)\n  // instead of routes with hashes (e.g. example.com/#/about).\n  // This may require some server configuration in production:\n  // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n  mode: 'history',\n  // Simulate native-like scroll behavior when navigating to a new\n  // route and using back/forward buttons.\n  scrollBehavior: function scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition;\n    } else {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n  }\n}); // Before each route evaluates...\n\nrouter.beforeEach(function (routeTo, routeFrom, next) {\n  // If this isn't an initial page load...\n  if (routeFrom.name !== null) {\n    // Start the route progress bar.\n    NProgress.start();\n  } // Check if auth is required on this route\n  // (including nested routes).\n\n\n  var authRequired = routeTo.matched.some(function (route) {\n    return route.meta.authRequired;\n  }); // If auth isn't required for the route, just continue.\n\n  if (!authRequired) return next(); // If auth is required and the user is logged in...\n\n  if (store.getters['auth/loggedIn']) {\n    // Validate the local user token...\n    return store.dispatch('auth/validate').then(function (validUser) {\n      // Then continue if the token still represents a valid user,\n      // otherwise redirect to login.\n      validUser ? next() : redirectToLogin();\n    });\n  } // If auth is required and the user is NOT currently logged in,\n  // redirect to login.\n\n\n  redirectToLogin();\n\n  function redirectToLogin() {\n    // Pass the original route to the login component\n    next({\n      name: 'login',\n      query: {\n        redirectFrom: routeTo.fullPath\n      }\n    });\n  }\n});\nrouter.beforeResolve(\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee(routeTo, routeFrom, next) {\n    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;\n\n    return regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            // For each matched route...\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _iteratorError = undefined;\n            _context2.prev = 4;\n            _loop =\n            /*#__PURE__*/\n            regeneratorRuntime.mark(function _loop() {\n              var route;\n              return regeneratorRuntime.wrap(function _loop$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      route = _step.value;\n                      _context.next = 3;\n                      return new Promise(function (resolve, reject) {\n                        // If a `beforeResolve` hook is defined, call it with\n                        // the same arguments as the `beforeEnter` hook.\n                        if (route.meta && route.meta.beforeResolve) {\n                          route.meta.beforeResolve(routeTo, routeFrom, function () {\n                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                              args[_key] = arguments[_key];\n                            }\n\n                            // If the user chose to redirect...\n                            if (args.length) {\n                              // If redirecting to the same route we're coming from...\n                              if (routeFrom.name === args[0].name) {\n                                // Complete the animation of the route progress bar.\n                                NProgress.done();\n                              } // Complete the redirect.\n\n\n                              next.apply(void 0, args);\n                              reject(new Error('Redirected'));\n                            } else {\n                              resolve();\n                            }\n                          });\n                        } else {\n                          // Otherwise, continue resolving the route.\n                          resolve();\n                        }\n                      });\n\n                    case 3:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _loop, this);\n            });\n            _iterator = routeTo.matched[Symbol.iterator]();\n\n          case 7:\n            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n              _context2.next = 12;\n              break;\n            }\n\n            return _context2.delegateYield(_loop(), \"t0\", 9);\n\n          case 9:\n            _iteratorNormalCompletion = true;\n            _context2.next = 7;\n            break;\n\n          case 12:\n            _context2.next = 18;\n            break;\n\n          case 14:\n            _context2.prev = 14;\n            _context2.t1 = _context2[\"catch\"](4);\n            _didIteratorError = true;\n            _iteratorError = _context2.t1;\n\n          case 18:\n            _context2.prev = 18;\n            _context2.prev = 19;\n\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n\n          case 21:\n            _context2.prev = 21;\n\n            if (!_didIteratorError) {\n              _context2.next = 24;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 24:\n            return _context2.finish(21);\n\n          case 25:\n            return _context2.finish(18);\n\n          case 26:\n            _context2.next = 31;\n            break;\n\n          case 28:\n            _context2.prev = 28;\n            _context2.t2 = _context2[\"catch\"](0);\n            return _context2.abrupt(\"return\");\n\n          case 31:\n            // If we reach this point, continue resolving the route.\n            next();\n\n          case 32:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, this, [[0, 28], [4, 14, 18, 26], [19,, 21, 25]]);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}()); // When each route is finished evaluating...\n\nrouter.afterEach(function (routeTo, routeFrom) {\n  // Complete the animation of the route progress bar.\n  NProgress.done();\n});\nexport default router;",{"version":3,"sources":["/var/www/vue_enterprise/client/src/router/index.js"],"names":["Vue","VueRouter","VueMeta","NProgress","store","routes","use","keyName","router","mode","scrollBehavior","to","from","savedPosition","x","y","beforeEach","routeTo","routeFrom","next","name","start","authRequired","matched","some","route","meta","getters","dispatch","then","validUser","redirectToLogin","query","redirectFrom","fullPath","beforeResolve","Promise","resolve","reject","args","length","done","Error","afterEach"],"mappings":";;;;;;AAAA,OAAOA,GAAP,MAAgB,KAAhB;AACA,OAAOC,SAAP,MAAsB,YAAtB,C,CACA;;AACA,OAAOC,OAAP,MAAoB,UAApB,C,CACA;;AACA,OAAOC,SAAP,MAAsB,qBAAtB;AACA,OAAOC,KAAP,MAAkB,cAAlB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AAEAL,GAAG,CAACM,GAAJ,CAAQL,SAAR;AACAD,GAAG,CAACM,GAAJ,CAAQJ,OAAR,EAAiB;AACf;AACAK,EAAAA,OAAO,EAAE;AAFM,CAAjB;AAKA,IAAMC,MAAM,GAAG,IAAIP,SAAJ,CAAc;AAC3BI,EAAAA,MAAM,EAANA,MAD2B;AAE3B;AACA;AACA;AACA;AACAI,EAAAA,IAAI,EAAE,SANqB;AAO3B;AACA;AACAC,EAAAA,cAT2B,0BASZC,EATY,EASRC,IATQ,EASFC,aATE,EASa;AACtC,QAAIA,aAAJ,EAAmB;AACjB,aAAOA,aAAP;AACD,KAFD,MAEO;AACL,aAAO;AAAEC,QAAAA,CAAC,EAAE,CAAL;AAAQC,QAAAA,CAAC,EAAE;AAAX,OAAP;AACD;AACF;AAf0B,CAAd,CAAf,C,CAkBA;;AACAP,MAAM,CAACQ,UAAP,CAAkB,UAACC,OAAD,EAAUC,SAAV,EAAqBC,IAArB,EAA8B;AAC9C;AACA,MAAID,SAAS,CAACE,IAAV,KAAmB,IAAvB,EAA6B;AAC3B;AACAjB,IAAAA,SAAS,CAACkB,KAAV;AACD,GAL6C,CAO9C;AACA;;;AACA,MAAMC,YAAY,GAAGL,OAAO,CAACM,OAAR,CAAgBC,IAAhB,CAAqB,UAACC,KAAD;AAAA,WAAWA,KAAK,CAACC,IAAN,CAAWJ,YAAtB;AAAA,GAArB,CAArB,CAT8C,CAW9C;;AACA,MAAI,CAACA,YAAL,EAAmB,OAAOH,IAAI,EAAX,CAZ2B,CAc9C;;AACA,MAAIf,KAAK,CAACuB,OAAN,CAAc,eAAd,CAAJ,EAAoC;AAClC;AACA,WAAOvB,KAAK,CAACwB,QAAN,CAAe,eAAf,EAAgCC,IAAhC,CAAqC,UAACC,SAAD,EAAe;AACzD;AACA;AACAA,MAAAA,SAAS,GAAGX,IAAI,EAAP,GAAYY,eAAe,EAApC;AACD,KAJM,CAAP;AAKD,GAtB6C,CAwB9C;AACA;;;AACAA,EAAAA,eAAe;;AAEf,WAASA,eAAT,GAA2B;AACzB;AACAZ,IAAAA,IAAI,CAAC;AAAEC,MAAAA,IAAI,EAAE,OAAR;AAAiBY,MAAAA,KAAK,EAAE;AAAEC,QAAAA,YAAY,EAAEhB,OAAO,CAACiB;AAAxB;AAAxB,KAAD,CAAJ;AACD;AACF,CAhCD;AAkCA1B,MAAM,CAAC2B,aAAP;AAAA;AAAA;AAAA;AAAA;AAAA,0BAAqB,iBAAOlB,OAAP,EAAgBC,SAAhB,EAA2BC,IAA3B;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAQjB;AARiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASNM,sBAAAA,KATM;AAAA;AAAA,6BAUT,IAAIW,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACrC;AACA;AACA,4BAAIb,KAAK,CAACC,IAAN,IAAcD,KAAK,CAACC,IAAN,CAAWS,aAA7B,EAA4C;AAC1CV,0BAAAA,KAAK,CAACC,IAAN,CAAWS,aAAX,CAAyBlB,OAAzB,EAAkCC,SAAlC,EAA6C,YAAa;AAAA,8DAATqB,IAAS;AAATA,8BAAAA,IAAS;AAAA;;AACxD;AACA,gCAAIA,IAAI,CAACC,MAAT,EAAiB;AACf;AACA,kCAAItB,SAAS,CAACE,IAAV,KAAmBmB,IAAI,CAAC,CAAD,CAAJ,CAAQnB,IAA/B,EAAqC;AACnC;AACAjB,gCAAAA,SAAS,CAACsC,IAAV;AACD,+BALc,CAMf;;;AACAtB,8BAAAA,IAAI,MAAJ,SAAQoB,IAAR;AACAD,8BAAAA,MAAM,CAAC,IAAII,KAAJ,CAAU,YAAV,CAAD,CAAN;AACD,6BATD,MASO;AACLL,8BAAAA,OAAO;AACR;AACF,2BAdD;AAeD,yBAhBD,MAgBO;AACL;AACAA,0BAAAA,OAAO;AACR;AACF,uBAvBK,CAVS;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBASGpB,OAAO,CAACM,OATX;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAwCnB;AACAJ,YAAAA,IAAI;;AAzCe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAArB;;AAAA;AAAA;AAAA;AAAA,K,CA4CA;;AACAX,MAAM,CAACmC,SAAP,CAAiB,UAAC1B,OAAD,EAAUC,SAAV,EAAwB;AACvC;AACAf,EAAAA,SAAS,CAACsC,IAAV;AACD,CAHD;AAKA,eAAejC,MAAf","sourcesContent":["import Vue from 'vue'\nimport VueRouter from 'vue-router'\n// https://github.com/declandewet/vue-meta\nimport VueMeta from 'vue-meta'\n// Adds a loading bar at the top during page loads.\nimport NProgress from 'nprogress/nprogress'\nimport store from '@state/store'\nimport routes from './routes'\n\nVue.use(VueRouter)\nVue.use(VueMeta, {\n  // The component option name that vue-meta looks for meta info on.\n  keyName: 'page',\n})\n\nconst router = new VueRouter({\n  routes,\n  // Use the HTML5 history API (i.e. normal-looking routes)\n  // instead of routes with hashes (e.g. example.com/#/about).\n  // This may require some server configuration in production:\n  // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n  mode: 'history',\n  // Simulate native-like scroll behavior when navigating to a new\n  // route and using back/forward buttons.\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition\n    } else {\n      return { x: 0, y: 0 }\n    }\n  },\n})\n\n// Before each route evaluates...\nrouter.beforeEach((routeTo, routeFrom, next) => {\n  // If this isn't an initial page load...\n  if (routeFrom.name !== null) {\n    // Start the route progress bar.\n    NProgress.start()\n  }\n\n  // Check if auth is required on this route\n  // (including nested routes).\n  const authRequired = routeTo.matched.some((route) => route.meta.authRequired)\n\n  // If auth isn't required for the route, just continue.\n  if (!authRequired) return next()\n\n  // If auth is required and the user is logged in...\n  if (store.getters['auth/loggedIn']) {\n    // Validate the local user token...\n    return store.dispatch('auth/validate').then((validUser) => {\n      // Then continue if the token still represents a valid user,\n      // otherwise redirect to login.\n      validUser ? next() : redirectToLogin()\n    })\n  }\n\n  // If auth is required and the user is NOT currently logged in,\n  // redirect to login.\n  redirectToLogin()\n\n  function redirectToLogin() {\n    // Pass the original route to the login component\n    next({ name: 'login', query: { redirectFrom: routeTo.fullPath } })\n  }\n})\n\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\n  // Create a `beforeResolve` hook, which fires whenever\n  // `beforeRouteEnter` and `beforeRouteUpdate` would. This\n  // allows us to ensure data is fetched even when params change,\n  // but the resolved route does not. We put it in `meta` to\n  // indicate that it's a hook we created, rather than part of\n  // Vue Router (yet?).\n  try {\n    // For each matched route...\n    for (const route of routeTo.matched) {\n      await new Promise((resolve, reject) => {\n        // If a `beforeResolve` hook is defined, call it with\n        // the same arguments as the `beforeEnter` hook.\n        if (route.meta && route.meta.beforeResolve) {\n          route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n            // If the user chose to redirect...\n            if (args.length) {\n              // If redirecting to the same route we're coming from...\n              if (routeFrom.name === args[0].name) {\n                // Complete the animation of the route progress bar.\n                NProgress.done()\n              }\n              // Complete the redirect.\n              next(...args)\n              reject(new Error('Redirected'))\n            } else {\n              resolve()\n            }\n          })\n        } else {\n          // Otherwise, continue resolving the route.\n          resolve()\n        }\n      })\n    }\n    // If a `beforeResolve` hook chose to redirect, just return.\n  } catch (error) {\n    return\n  }\n\n  // If we reach this point, continue resolving the route.\n  next()\n})\n\n// When each route is finished evaluating...\nrouter.afterEach((routeTo, routeFrom) => {\n  // Complete the animation of the route progress bar.\n  NProgress.done()\n})\n\nexport default router\n"]}]}